// automatically generated by Xtext
grammar de.altimos.mdsd.majordomo.dsl.MajordomoDsl with org.eclipse.xtext.common.Terminals

import "platform:/resource/de.altimos.mdsd.majordomo/model/majordomo.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Majordomo:
	{Majordomo}
	(house=House)?
	(rooms+=Room)*
	program=Program
;

Program:
	{Program}
	'program'
	'{'
		(
			(rules+=Rule ';'?) |
			(preparedStatements+=PreparedStatement ';'?) |
			(preparedActionSets+=PreparedActionSet ';'?) |
			(constants+=PreparedValue ';'?)
		)*
	'}'
;

House:
	{House}
	'house'
	'{'
		((sensors+=Sensor|actors+=Actor) ';'?)*
	'}'
;

Room:
	{Room}
	'room'
	name=Name
	'{'
		((sensors+=Sensor|actors+=Actor) ';'?)*
	'}'
;

Sensor:
	LightSensor | TemperatureSensor | RainSensor | SwitchSensor | NumberSensor | ClockSensor
;

Actor:
	LampActor | RollerActor | RoofWindowActor | RadiatorActor | BoilerActor | CoffeeActor
;

// Rules and Statements
//
Rule:
	'on' statement=Statement 'do' (actions+=Action)(',' (actions+=Action))*
;

Statement returns Statement:
	BinaryOrOperation
;
BinaryOrOperation returns Statement:
	BinaryAndOperation ({BinaryOrOperation.left=current} BinaryOrOperator right=BinaryAndOperation)*
;
BinaryAndOperation returns Statement:
	NotOperation ({BinaryAndOperation.left=current} BinaryAndOperator right=NotOperation)*
;
NotOperation returns Statement:
	UnaryStatement | ({NotOperation} ('not' | '!') statement=UnaryStatement)
;
UnaryStatement returns Statement:
	('(' Statement ')') | StatementReference | BooleanSensorStatement | CompareOperation
;

BooleanSensorStatement:
	sensor=[BooleanSensor|QualifiedName] '?'
;

// Compare Statements
//
CompareOperation:
	left=ValueExpression comparator=Comparator right=ValueExpression
;
ValueExpression: 
	SensorValue | ConstantValue | ValueReference
;
SensorValue: 
	sensor=[FloatSensor|QualifiedName]
;
ConstantValue: 
	value=EFloat
;
ValueReference: 
	ref=[PreparedValue|ConstID]
;


// Prepared Statements, Statement References, Consts
//
PreparedStatement: 
	'def' name=Name ':' statement=Statement
;
StatementReference: 
	ref=[PreparedStatement|Name]
;
PreparedActionSet: 
	'set' name=Name ':' actions+=Action (',' actions+=Action)*
;
ActionSetReference: 
	ref=[PreparedActionSet|Name]
;
PreparedValue:
	'val' name=ConstID ':' value=ValueExpression
;

// Actions
//
Action: 
	BooleanAction | FloatAction | ActionSetReference
;
BooleanAction:
	actor=[BooleanActor|QualifiedName] ':' value=EBoolean
;
FloatAction:
	actor=[FloatActor|QualifiedName] ':' value=EFloat
;

// Sensors
//
LightSensor:		'@light'	name=Name;
TemperatureSensor:	'@temp'		name=Name;
RainSensor:			'@rain'		name=Name;
SwitchSensor:		'@switch'	name=Name;
NumberSensor:		'@number'	name=Name;
ClockSensor:		'@clock'	name=Name;

// Actors
//
LampActor:			'@lamp'		name=Name;
RollerActor:		'@roller'	name=Name;
RoofWindowActor:	'@roof'		name=Name;
RadiatorActor:		'@radiator'	name=Name;
BoilerActor:		'@boiler'	name=Name;
CoffeeActor:		'@coffee'	name=Name;

// Operators, Enumerations, Values, Identifiers
// name system: full qualified names used for cross-referencing
//
Name: ID;
QualifiedName: Name ('.' Name)*;

ConstID: CONST;
terminal CONST: ('A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

BinaryAndOperator: "and" | "&&" | "&";
BinaryOrOperator: "or" | "||" | "|";
	
enum Comparator: 
	LT="<" | LE="<=" | GE=">=" | GT=">";

EFloat returns ecore::EFloat:
	'-'? INT? ('.' INT (('E'|'e') '-'? INT)?)?;

EBoolean returns ecore::EBoolean:
	'true' | 'false';
